â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
GUÃA DE IMPLEMENTACIÃ“N: PAGINACIÃ“N SERVER-SIDE PARA TABLAS GRANDES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Proyecto: JoySense Dashboard
Fecha: Octubre 2025
Autor: ImplementaciÃ³n basada en estÃ¡ndares empresariales

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ PROBLEMA QUE RESUELVE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Supabase tiene un LÃMITE de 1000 registros por query
2. Tablas con mÃ¡s de 1000 registros no se mostraban completamente
3. Tablas como metricasensor, sensor, nodo, alerta crecen exponencialmente
4. Se necesitaba una soluciÃ³n escalable para producciÃ³n

EJEMPLO DEL PROBLEMA:
- Tabla metricasensor tenÃ­a 1401 registros
- Frontend solo mostraba 1000
- Los Ãºltimos 401 registros eran invisibles
- Usuarios reportaban datos "perdidos"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âœ… SOLUCIÃ“N IMPLEMENTADA: ARQUITECTURA DE 2 MODOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

MODO 1: MODO LEGACY (sin parÃ¡metro 'page')
  - Comportamiento: Carga TODOS los registros automÃ¡ticamente
  - Uso: Compatibilidad con cÃ³digo existente
  - ImplementaciÃ³n: Fetch automÃ¡tico en chunks de 1000
  - Log: "ğŸ“š Modo legacy: Cargando todos los registros de [tabla]"

MODO 2: MODO PAGINADO (con parÃ¡metro 'page')
  - Comportamiento: Carga solo 1 pÃ¡gina a la vez
  - Uso: Para UIs con controles de paginaciÃ³n
  - ImplementaciÃ³n: range(offset, offset + pageSize - 1)
  - Response: { data: [], pagination: { page, pageSize, total, totalPages } }

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ PASO 1: BACKEND - HELPER DE PAGINACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Archivo: backend/server.js
UbicaciÃ³n: LÃ­neas 42-180
FunciÃ³n: paginateAndFilter(tableName, params)

// ============================================================================
// HELPER: PAGINACIÃ“N, BÃšSQUEDA Y FILTROS
// ============================================================================

// Configurar campos donde se puede buscar por texto
const SEARCHABLE_FIELDS = {
  metricasensor: ['nodoid', 'tipoid', 'metricaid'],
  sensor: ['nodoid', 'tipoid'],
  nodo: ['nodo', 'nodoid'],
  alerta: ['nodoid', 'alerta'],
  umbral: ['nodoid', 'tipoid', 'metricaid'],
  medicion: ['nodoid', 'medicion'],
  localizacion: ['nodoid', 'ubicacionid'],
  usuario: ['login', 'nombre', 'email'],
  // AGREGAR MÃS TABLAS SEGÃšN NECESIDAD
};

async function paginateAndFilter(tableName, params = {}) {
  const {
    page,                    // NÃºmero de pÃ¡gina (1, 2, 3...) - OPCIONAL
    pageSize = 100,          // Registros por pÃ¡gina - DEFAULT: 100
    search = '',             // Texto de bÃºsqueda - OPCIONAL
    sortBy = 'datemodified', // Campo para ordenar - DEFAULT: datemodified
    sortOrder = 'desc',      // asc o desc - DEFAULT: desc
    ...filters               // Filtros adicionales (paisid, empresaid, statusid, etc.)
  } = params;

  // Determinar si usar paginaciÃ³n o modo legacy
  const usePagination = page !== undefined && page !== null;

  try {
    // ========================================================================
    // 1. CONSTRUIR QUERY BASE
    // ========================================================================
    let query = supabase.from(tableName).select('*', { count: 'exact' });

    // ========================================================================
    // 2. APLICAR FILTROS (paisid, empresaid, fundoid, statusid, etc.)
    // ========================================================================
    Object.keys(filters).forEach(key => {
      if (filters[key] !== undefined && filters[key] !== null && filters[key] !== '') {
        query = query.eq(key, filters[key]);
      }
    });

    // ========================================================================
    // 3. APLICAR BÃšSQUEDA (OR entre campos definidos en SEARCHABLE_FIELDS)
    // ========================================================================
    if (search && search.trim() !== '') {
      const searchFields = SEARCHABLE_FIELDS[tableName] || [];
      if (searchFields.length > 0) {
        const searchConditions = searchFields.map(field => 
          `${field}.ilike.%${search}%`
        ).join(',');
        query = query.or(searchConditions);
      }
    }

    // ========================================================================
    // 4. OBTENER TOTAL DE REGISTROS (para calcular pÃ¡ginas)
    // ========================================================================
    const { count: totalRecords } = await query;

    // ========================================================================
    // 5. APLICAR ORDENAMIENTO
    // ========================================================================
    if (sortBy) {
      query = query.order(sortBy, { ascending: sortOrder === 'asc' });
    }

    // ========================================================================
    // 6A. MODO PAGINADO: Cargar solo 1 pÃ¡gina
    // ========================================================================
    if (usePagination) {
      const offset = (page - 1) * pageSize;
      query = query.range(offset, offset + pageSize - 1);
      
      const { data, error } = await query;
      if (error) throw error;

      // Devolver objeto con data + pagination info
      return {
        data: data || [],
        pagination: {
          page: parseInt(page),
          pageSize: parseInt(pageSize),
          total: totalRecords || 0,
          totalPages: Math.ceil((totalRecords || 0) / pageSize)
        }
      };
    }

    // ========================================================================
    // 6B. MODO LEGACY: Cargar TODOS los registros en chunks de 1000
    // ========================================================================
    else {
      console.log(`ğŸ“š Modo legacy: Cargando todos los registros de ${tableName}`);
      
      let allData = [];
      let currentOffset = 0;
      const chunkSize = 1000; // LÃ­mite de Supabase

      // Loop para obtener todos los registros en chunks
      while (true) {
        const { data: chunk, error } = await supabase
          .from(tableName)
          .select('*')
          .range(currentOffset, currentOffset + chunkSize - 1)
          .order(sortBy, { ascending: sortOrder === 'asc' });

        if (error) throw error;
        if (!chunk || chunk.length === 0) break;

        allData = allData.concat(chunk);
        
        // Si recibimos menos de 1000, ya no hay mÃ¡s registros
        if (chunk.length < chunkSize) break;
        
        currentOffset += chunkSize;
      }

      // Devolver array directo (sin pagination object)
      return allData;
    }

  } catch (error) {
    console.error(`âŒ Error en paginateAndFilter para ${tableName}:`, error);
    throw error;
  }
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ PASO 2: BACKEND - APLICAR EN ENDPOINTS GET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PATRÃ“N ESTÃNDAR para todos los endpoints GET:

app.get('/api/sense/[TABLA]', async (req, res) => {
  try {
    console.log('ğŸ” Backend: Obteniendo [TABLA] del schema sense...');
    
    // Usar helper de paginaciÃ³n con query params del request
    const result = await paginateAndFilter('[TABLA]', req.query);
    
    // Verificar si es modo paginado o legacy
    if (result.pagination) {
      // MODO PAGINADO: devolver objeto con data + pagination
      console.log(`âœ… Backend: [TABLA] obtenidos: ${result.data.length} de ${result.pagination.total}`);
      res.json(result);
    } else {
      // MODO LEGACY: devolver array directo
      console.log(`âœ… Backend: [TABLA] obtenidos (modo legacy): ${result.length}`);
      res.json(result);
    }
    
  } catch (error) {
    console.error('âŒ Error in /api/sense/[TABLA]:', error);
    res.status(500).json({ error: error.message });
  }
});


EJEMPLO REAL - METRICASENSOR:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.get('/api/sense/metricasensor', async (req, res) => {
  try {
    console.log('ğŸ” Backend: Obteniendo metricasensor del schema sense...');
    const result = await paginateAndFilter('metricasensor', req.query);
    
    if (result.pagination) {
      console.log(`âœ… Backend: Metricasensor obtenidos: ${result.data.length} de ${result.pagination.total}`);
      res.json(result);
    } else {
      console.log(`âœ… Backend: Metricasensor obtenidos (modo legacy): ${result.length}`);
      res.json(result);
    }
  } catch (error) {
    console.error('âŒ Error in /api/sense/metricasensor:', error);
    res.status(500).json({ error: error.message });
  }
});


EJEMPLO REAL - SENSOR:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

app.get('/api/sense/sensor', async (req, res) => {
  try {
    console.log('ğŸ” Backend: Obteniendo sensor del schema sense...');
    const result = await paginateAndFilter('sensor', req.query);
    
    if (result.pagination) {
      console.log(`âœ… Backend: Sensor obtenidos: ${result.data.length} de ${result.pagination.total}`);
      res.json(result);
    } else {
      console.log(`âœ… Backend: Sensor obtenidos (modo legacy): ${result.length}`);
      res.json(result);
    }
  } catch (error) {
    console.error('âŒ Error in /api/sense/sensor:', error);
    res.status(500).json({ error: error.message });
  }
});


TABLAS QUE DEBEN USAR PAGINACIÃ“N:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CRÃTICAS (crecimiento exponencial):
  âœ… metricasensor  - MÃ©tricas de sensores
  âœ… sensor         - Sensores por nodo
  âœ… nodo           - Nodos LoRaWAN
  âœ… alerta         - Alertas generadas
  âœ… umbral         - Umbrales de alertas
  âœ… medicion       - Mediciones de sensores
  âœ… mensaje        - Mensajes de alertas
  âœ… localizacion   - Localizaciones fÃ­sicas

OPCIONALES (bajo crecimiento):
  âš ï¸ usuario        - Usuarios del sistema
  âš ï¸ usuarioperfil  - Perfiles de usuario

NO NECESARIAS (catÃ¡logos pequeÃ±os):
  âŒ pais           - Lista de paÃ­ses
  âŒ empresa        - Empresas registradas
  âŒ fundo          - Fundos/fincas
  âŒ entidad        - Entidades de sensores
  âŒ tipo           - Tipos de sensores
  âŒ metrica        - MÃ©tricas disponibles
  âŒ criticidad     - Niveles de criticidad
  âŒ status         - Estados del sistema

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ PASO 3: FRONTEND - SERVICIO API
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Archivo: frontend/src/services/backend-api.ts
UbicaciÃ³n: Agregar como mÃ©todo estÃ¡tico de la clase JoySenseService

/**
 * Obtener datos de tabla con soporte para paginaciÃ³n
 * 
 * @param tableName - Nombre de la tabla
 * @param options - Opciones de paginaciÃ³n, bÃºsqueda y filtros
 * @returns Promise con { data: [], pagination?: {} }
 */
static async getTableDataPaginated(
  tableName: string, 
  options: { 
    page?: number;           // NÃºmero de pÃ¡gina (1, 2, 3...)
    pageSize?: number;       // Registros por pÃ¡gina
    search?: string;         // Texto de bÃºsqueda
    sortBy?: string;         // Campo para ordenar
    sortOrder?: 'asc' | 'desc'; // Orden
    [key: string]: any;      // Filtros adicionales (paisid, statusid, etc.)
  } = {}
): Promise<{ data: any[]; pagination?: any }> {
  try {
    // Construir query params
    const params = new URLSearchParams();
    
    Object.keys(options).forEach(key => {
      if (options[key] !== undefined && options[key] !== null && options[key] !== '') {
        params.append(key, String(options[key]));
      }
    });

    const queryString = params.toString();
    const endpoint = `/sense/${tableName}${queryString ? '?' + queryString : ''}`;
    
    // Llamar al backend
    const response = await backendAPI.get(endpoint);
    
    // Si tiene pagination object, es modo paginado
    if (response && response.pagination) {
      return response; // { data: [], pagination: {} }
    }
    
    // Si no, es modo legacy (array directo)
    const data = Array.isArray(response) ? response : (response?.data || []);
    return { data }; // { data: [] }
    
  } catch (error) {
    console.error(`Error in getTableDataPaginated for ${tableName}:`, error);
    throw error;
  }
}


USO EN COMPONENTES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// MODO LEGACY (sin page): carga TODOS los registros
const result = await JoySenseService.getTableDataPaginated('metricasensor');
console.log(result.data); // Array con TODOS los registros


// MODO PAGINADO (con page): carga solo 1 pÃ¡gina
const result = await JoySenseService.getTableDataPaginated('metricasensor', {
  page: 1,
  pageSize: 100,
  search: 'temperatura',
  statusid: 1
});
console.log(result.data);       // Array con 100 registros
console.log(result.pagination); // { page: 1, pageSize: 100, total: 1401, totalPages: 15 }


// MODO PAGINADO con filtros adicionales
const result = await JoySenseService.getTableDataPaginated('sensor', {
  page: 2,
  pageSize: 50,
  nodoid: 256,
  statusid: 1,
  sortBy: 'datecreated',
  sortOrder: 'asc'
});

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ PASO 4: FRONTEND - HOOK DE PAGINACIÃ“N (OPCIONAL)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Archivo: frontend/src/hooks/useServerPagination.ts

import { useState } from 'react';

/**
 * Hook para manejar paginaciÃ³n server-side
 * 
 * @param initialPageSize - TamaÃ±o inicial de pÃ¡gina (default: 100)
 * @returns Objeto con estado y funciones de paginaciÃ³n
 */
export function useServerPagination(initialPageSize = 100) {
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize, setPageSize] = useState(initialPageSize);
  const [totalRecords, setTotalRecords] = useState(0);
  const [totalPages, setTotalPages] = useState(0);

  /**
   * Cambiar a una pÃ¡gina especÃ­fica
   */
  const handlePageChange = (newPage: number) => {
    if (newPage >= 1 && newPage <= totalPages) {
      setCurrentPage(newPage);
    }
  };

  /**
   * Cambiar tamaÃ±o de pÃ¡gina
   */
  const handlePageSizeChange = (newSize: number) => {
    setPageSize(newSize);
    setCurrentPage(1); // Reset a primera pÃ¡gina
  };

  /**
   * Actualizar informaciÃ³n de paginaciÃ³n desde response del backend
   */
  const updatePaginationInfo = (pagination: any) => {
    if (pagination) {
      setTotalRecords(pagination.total || 0);
      setTotalPages(pagination.totalPages || 0);
    }
  };

  /**
   * Reset a estado inicial
   */
  const resetPagination = () => {
    setCurrentPage(1);
    setTotalRecords(0);
    setTotalPages(0);
  };

  return {
    // Estado
    currentPage,
    pageSize,
    totalRecords,
    totalPages,
    
    // Funciones
    handlePageChange,
    handlePageSizeChange,
    updatePaginationInfo,
    resetPagination,
    
    // Helpers
    hasNextPage: currentPage < totalPages,
    hasPrevPage: currentPage > 1
  };
}


USO EN COMPONENTE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

import { useServerPagination } from '../hooks/useServerPagination';
import { JoySenseService } from '../services/backend-api';

function MiComponente() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  
  const { 
    currentPage, 
    pageSize, 
    totalRecords,
    totalPages,
    handlePageChange, 
    handlePageSizeChange,
    updatePaginationInfo,
    hasNextPage,
    hasPrevPage
  } = useServerPagination(100);

  const loadData = async () => {
    try {
      setLoading(true);
      
      const result = await JoySenseService.getTableDataPaginated('metricasensor', {
        page: currentPage,
        pageSize: pageSize,
        statusid: 1
      });
      
      setData(result.data);
      
      if (result.pagination) {
        updatePaginationInfo(result.pagination);
      }
      
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      setLoading(false);
    }
  };

  // Cargar datos cuando cambie la pÃ¡gina
  useEffect(() => {
    loadData();
  }, [currentPage, pageSize]);

  return (
    <div>
      {/* Tabla de datos */}
      <table>
        <thead>
          <tr>
            <th>Nodo</th>
            <th>Tipo</th>
            <th>MÃ©trica</th>
          </tr>
        </thead>
        <tbody>
          {loading ? (
            <tr><td colSpan={3}>Cargando...</td></tr>
          ) : (
            data.map(row => (
              <tr key={`${row.nodoid}-${row.tipoid}-${row.metricaid}`}>
                <td>{row.nodoid}</td>
                <td>{row.tipoid}</td>
                <td>{row.metricaid}</td>
              </tr>
            ))
          )}
        </tbody>
      </table>

      {/* Controles de paginaciÃ³n */}
      <div className="pagination-controls">
        <button 
          onClick={() => handlePageChange(1)} 
          disabled={!hasPrevPage}
        >
          Primera
        </button>
        
        <button 
          onClick={() => handlePageChange(currentPage - 1)} 
          disabled={!hasPrevPage}
        >
          Anterior
        </button>
        
        <span>
          PÃ¡gina {currentPage} de {totalPages} ({totalRecords} registros)
        </span>
        
        <button 
          onClick={() => handlePageChange(currentPage + 1)} 
          disabled={!hasNextPage}
        >
          Siguiente
        </button>
        
        <button 
          onClick={() => handlePageChange(totalPages)} 
          disabled={!hasNextPage}
        >
          Ãšltima
        </button>
        
        {/* Selector de tamaÃ±o de pÃ¡gina */}
        <select 
          value={pageSize} 
          onChange={(e) => handlePageSizeChange(Number(e.target.value))}
        >
          <option value={50}>50 por pÃ¡gina</option>
          <option value={100}>100 por pÃ¡gina</option>
          <option value={200}>200 por pÃ¡gina</option>
        </select>
      </div>
    </div>
  );
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ PASO 5: FRONTEND - COMPONENTE DE CONTROLES DE PAGINACIÃ“N (OPCIONAL)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Archivo: frontend/src/components/PaginationControls.tsx

import React from 'react';

interface PaginationControlsProps {
  currentPage: number;
  totalPages: number;
  totalRecords: number;
  pageSize: number;
  onPageChange: (page: number) => void;
  onPageSizeChange: (size: number) => void;
  hasNextPage: boolean;
  hasPrevPage: boolean;
}

export function PaginationControls({
  currentPage,
  totalPages,
  totalRecords,
  pageSize,
  onPageChange,
  onPageSizeChange,
  hasNextPage,
  hasPrevPage
}: PaginationControlsProps) {
  
  return (
    <div className="flex items-center justify-between mt-4 px-4 py-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
      {/* InformaciÃ³n */}
      <div className="text-sm text-gray-700 dark:text-gray-300">
        Mostrando {((currentPage - 1) * pageSize) + 1} - {Math.min(currentPage * pageSize, totalRecords)} de {totalRecords} registros
      </div>

      {/* Controles */}
      <div className="flex items-center space-x-2">
        {/* Primera pÃ¡gina */}
        <button
          onClick={() => onPageChange(1)}
          disabled={!hasPrevPage}
          className="px-3 py-1 rounded bg-blue-500 text-white disabled:bg-gray-300 disabled:cursor-not-allowed"
        >
          Â«Â«
        </button>

        {/* PÃ¡gina anterior */}
        <button
          onClick={() => onPageChange(currentPage - 1)}
          disabled={!hasPrevPage}
          className="px-3 py-1 rounded bg-blue-500 text-white disabled:bg-gray-300 disabled:cursor-not-allowed"
        >
          Â«
        </button>

        {/* NÃºmero de pÃ¡gina */}
        <span className="px-4 py-1 text-sm">
          PÃ¡gina {currentPage} de {totalPages}
        </span>

        {/* PÃ¡gina siguiente */}
        <button
          onClick={() => onPageChange(currentPage + 1)}
          disabled={!hasNextPage}
          className="px-3 py-1 rounded bg-blue-500 text-white disabled:bg-gray-300 disabled:cursor-not-allowed"
        >
          Â»
        </button>

        {/* Ãšltima pÃ¡gina */}
        <button
          onClick={() => onPageChange(totalPages)}
          disabled={!hasNextPage}
          className="px-3 py-1 rounded bg-blue-500 text-white disabled:bg-gray-300 disabled:cursor-not-allowed"
        >
          Â»Â»
        </button>

        {/* Selector de tamaÃ±o */}
        <select
          value={pageSize}
          onChange={(e) => onPageSizeChange(Number(e.target.value))}
          className="ml-4 px-2 py-1 border rounded bg-white dark:bg-gray-700"
        >
          <option value={25}>25</option>
          <option value={50}>50</option>
          <option value={100}>100</option>
          <option value={200}>200</option>
        </select>
      </div>
    </div>
  );
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ RESUMEN: PASOS MÃNIMOS PARA REPLICAR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BACKEND (Node.js + Supabase):
  1. Copiar funciÃ³n paginateAndFilter() completa
  2. Configurar SEARCHABLE_FIELDS para tus tablas
  3. Actualizar endpoints GET para usar paginateAndFilter()
  4. Aplicar a tablas crÃ­ticas (ver lista arriba)

FRONTEND (React + TypeScript):
  1. Agregar mÃ©todo getTableDataPaginated() en servicio API
  2. (Opcional) Crear hook useServerPagination()
  3. (Opcional) Crear componente PaginationControls
  4. Actualizar componentes para usar nuevo mÃ©todo

TESTING:
  1. Sin 'page': GET /api/sense/metricasensor
     â†’ Debe devolver array con TODOS los registros
     â†’ Log: "ğŸ“š Modo legacy: Cargando todos los registros"
  
  2. Con 'page': GET /api/sense/metricasensor?page=1&pageSize=100
     â†’ Debe devolver { data: [], pagination: {} }
     â†’ Log: "âœ… Backend: Metricasensor obtenidos: 100 de 1401"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š BENEFICIOS DE ESTA IMPLEMENTACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… ESCALABILIDAD:
   - Soporta tablas con millones de registros
   - Rendimiento constante sin importar tamaÃ±o de tabla

âœ… COMPATIBILIDAD:
   - Modo legacy mantiene cÃ³digo existente funcionando
   - MigraciÃ³n gradual sin romper funcionalidad

âœ… FLEXIBILIDAD:
   - BÃºsqueda por texto en mÃºltiples campos
   - Filtros dinÃ¡micos (paisid, empresaid, statusid, etc.)
   - Ordenamiento configurable

âœ… PERFORMANCE:
   - Backend solo envÃ­a datos necesarios
   - Reduce carga de red y memoria del cliente
   - Queries optimizadas con indexes

âœ… UX PROFESIONAL:
   - Controles de navegaciÃ³n claros
   - InformaciÃ³n de registros visible
   - Carga rÃ¡pida de datos

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ CONSIDERACIONES IMPORTANTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. INDEXES DE BASE DE DATOS:
   - AsegÃºrate de tener indexes en campos de bÃºsqueda y ordenamiento
   - Ejemplo: CREATE INDEX idx_metricasensor_nodoid ON metricasensor(nodoid);

2. CACHÃ‰:
   - Considera implementar cachÃ© del lado del servidor (Redis)
   - Para queries frecuentes (ej: pÃ¡gina 1 con filtros comunes)

3. BÃšSQUEDA:
   - Para bÃºsquedas complejas, considera ElasticSearch o Algolia
   - La bÃºsqueda actual es bÃ¡sica (ILIKE)

4. REAL-TIME:
   - Si necesitas real-time, usa Supabase Realtime subscriptions
   - Solo para la pÃ¡gina actual, no todo el dataset

5. LIMITS:
   - Considera poner lÃ­mite mÃ¡ximo de pageSize (ej: 500)
   - Para evitar queries muy pesadas

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”— REFERENCIAS Y RECURSOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DocumentaciÃ³n Supabase:
  - Pagination: https://supabase.com/docs/guides/api/pagination
  - Range queries: https://postgrest.org/en/stable/references/api/pagination.html

EstÃ¡ndares de PaginaciÃ³n:
  - REST API Best Practices
  - Offset-based pagination (simple, implementado aquÃ­)
  - Cursor-based pagination (mejor para datasets muy grandes)
  - Keyset pagination (mejor performance, mÃ¡s complejo)

Proyecto Base:
  - JoySense Dashboard
  - GitHub: https://github.com/JemnerVera/lorawan-sense-app
  - Azure: agromigiva-joysense-dev

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ SOPORTE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Si tienes dudas al implementar esta soluciÃ³n:

1. Revisa los logs del backend
   - "ğŸ“š Modo legacy" significa que estÃ¡ funcionando sin paginaciÃ³n
   - "âœ… Backend: X de Y" significa que estÃ¡ paginando correctamente

2. Verifica el response del API
   - Sin paginaciÃ³n: Array directo []
   - Con paginaciÃ³n: { data: [], pagination: {} }

3. Debugging
   - Usa console.log para ver params que llegan al backend
   - Verifica que SEARCHABLE_FIELDS tenga tu tabla
   - Revisa que los nombres de campos coincidan con la DB

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FIN DE LA GUÃA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Implementado en JoySense Dashboard - Octubre 2025
Tested con 1400+ registros en producciÃ³n
Funcionando en Azure App Service (agromigiva-joysense-dev)

Esta implementaciÃ³n sigue estÃ¡ndares empresariales y es escalable para
aplicaciones de nivel producciÃ³n con millones de registros.

